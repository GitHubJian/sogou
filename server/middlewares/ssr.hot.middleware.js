const pathConfig = require('config').get('path');
const fs = require('fs');
const path = require('path');
const MFS = require('memory-fs');
const webpack = require('webpack');
const chokidar = require('chokidar');
const clientConfig = require('../../webpack/build/webpack.client.config');
const serverConfig = require('../../webpack/build/webpack.server.config');
const templatePath = path.resolve(pathConfig.template, 'ssr/template.html');
let template = fs.readFileSync(templatePath, 'utf-8');

const readFile = (fs, file) => {
    try {
        return fs.readFileSync(
            path.join(clientConfig.output.path, file),
            'utf-8'
        );
    } catch (e) {}
};

module.exports = function setupDevServer(app) {
    return async (ctx, next) => {
        let bundle;
        let template;
        let clientManifest;

        let ready;
        let renderer;

        const cb = (bundle, options) => {
            renderer = createRenderer(bundle, options);
        };

        const readyPromise = new Promise(r => {
            ready = r;
        });
        const update = () => {
            if (bundle && clientManifest) {
                ready();
                cb(bundle, {
                    template,
                    clientManifest
                });
            }
        };

        // read template from disk and watch
        template = fs.readFileSync(templatePath, 'utf-8');
        chokidar.watch(templatePath).on('change', () => {
            template = fs.readFileSync(templatePath, 'utf-8');
            console.log('index.html template updated.');
            update();
        });

        // modify client config to work with hot middleware
        clientConfig.entry.app = [
            'webpack-hot-middleware/client',
            clientConfig.entry.app
        ];
        clientConfig.output.filename = '[name].js';
        clientConfig.plugins.push(
            new webpack.HotModuleReplacementPlugin(),
            new webpack.NoEmitOnErrorsPlugin()
        );

        // dev middleware
        const clientCompiler = webpack(clientConfig);
        const devMiddleware = require('webpack-dev-middleware')(
            clientCompiler,
            {
                publicPath: clientConfig.output.publicPath,
                noInfo: true
            }
        );
        app.use(devMiddleware);
        clientCompiler.plugin('done', stats => {
            stats = stats.toJson();
            stats.errors.forEach(err => console.error(err));
            stats.warnings.forEach(err => console.warn(err));
            if (stats.errors.length) return;
            clientManifest = JSON.parse(
                readFile(
                    devMiddleware.fileSystem,
                    'vue-ssr-client-manifest.json'
                )
            );
            update();
        });

        // hot middleware
        app.use(
            require('webpack-hot-middleware')(clientCompiler, {
                heartbeat: 5000
            })
        );

        // watch and update server renderer
        const serverCompiler = webpack(serverConfig);
        const mfs = new MFS();
        serverCompiler.outputFileSystem = mfs;
        serverCompiler.watch({}, (err, stats) => {
            if (err) throw err;
            stats = stats.toJson();
            if (stats.errors.length) return;

            // read bundle generated by vue-ssr-webpack-plugin
            bundle = JSON.parse(readFile(mfs, 'vue-ssr-server-bundle.json'));
            update();
        });

        function render() {
            return new Promise((resolve, reject) => {
                readyPromise.then(() => {
                    const context = {
                        title: 'text',
                        url: ctx.path
                    };

                    renderer.renderToString(context, (err, html) => {
                        if (err) {
                            reject(err);
                            ctx.body = err;
                        } else {
                            resolve(html);
                        }
                    });
                });
            });
        }
        
        try {
            let html = await render();
            ctx.body = html;
        } catch (e) {
            ctx.body = e;
        }
    };
};
